<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta description="TKAN - A Cardano Trash Kan to clean up SCAM and unwanted tokens and protect the Cardano ecosystem.">
    <title>TKAN - The Cardano Trash Kan</title>
    <style>
        /* General Reset */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-x: hidden;
        }

        /* Top Section with Particles Background */
        header {
            position: relative;
            height: 300px;
            background: linear-gradient(145deg, #1e1e2f, #2c2c4a);
            color: white;
            text-align: center;
            overflow: hidden;
        }

        #particles-js {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        header img {
            z-index: 1;
            position: relative;
            border-radius: 50%;
            max-width: 150px;
        }

        header h1, header p {
            z-index: 1;
            position: relative;
            margin: 10px;
        }

        /* Content Section */
        .container {
            padding: 20px;
        }

        .send-tokens-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #007bff;
            color: #fff;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
        }

        .send-tokens-btn:hover {
            background: #0056b3;
        }

        h2, h3 {
            color: #1f1f1f;
        }

        .btn {
            display: inline-block;
            background: #007bff;
            color: #fff;
            padding: 10px 20px;
            margin: 20px 0;
            text-decoration: none;
            border-radius: 5px;
            cursor: pointer;
            border: none;
            font-size: 16px;
        }

        .btn:hover {
            background: #0056b3;
        }

        .wallet-info {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .wallet-info p {
            margin: 10px 0;
        }

        .wallet-info code {
            background-color: #f4f4f4;
            padding: 5px;
            border-radius: 3px;
            display: inline-block;
        }

        .footer {
            background: #1f1f1f;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            margin-top: 20px;
        }

        .social {
            margin-top: 10px;
        }

        .social a {
            color: #1da1f2;
            text-decoration: none;
        }

        .social a:hover {
            text-decoration: underline;
        }

        .token-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
        }

        .token-table th,
        .token-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .token-table th {
            background-color: #f5f5f5;
        }

        .token-table td.text-right {
            text-align: right;
        }

        .token-table tr:hover {
            background-color: #f9f9f9;
        }

        .token-table small {
            color: #666;
            font-family: monospace;
        }

        .wallet-balance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .balance-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .token-table-container {
            width: 100%;
            overflow-x: auto;
            margin-top: 1rem;
        }

        .token-table {
            width: 100%;
            min-width: 600px; /* Ensures table doesn't get too squeezed */
            border-collapse: collapse;
        }

        .token-table th,
        .token-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            white-space: nowrap; /* Prevents text wrapping */
        }

        .token-table td:nth-child(2) {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .token-table th {
            background-color: #f5f5f5;
            position: sticky;
            top: 0;
        }

        .token-table td.text-right {
            text-align: right;
        }

        .token-table tr:hover {
            background-color: #f9f9f9;
        }

        .token-table small {
            color: #666;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .wallet-balance-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 480px) {
            .wallet-balance-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <!-- Include Particle.js -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <!-- Include cbor-js library -->
    <script src="https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/cbor.js"></script>
</head>
<body>

<header>
    <div id="particles-js"></div>
    <img src="assets/TKAN-logo2.png" alt="TKAN Logo">
    <h1>TKAN - The Cardano Trash Kan</h1>
    <p>Guardians of Purity in the Cardano Ecosystem</p>
</header>

<div class="container">
    <a href="#send-tokens" class="send-tokens-btn">Send Tokens</a>

    <div class="story">
        <h2>Our Mission</h2>
        <p>
            The Cardano ecosystem is filled with clutter from harmful SCAM or unwanted tokens, and trash NFTs. These pollutants
            poison your wallet and the environment. TKAN aims to solve this by creating a "Trash Kan" on the Cardano blockchain.
        </p>
        <p>
            With TKAN, you can send any SCAM or unwanted tokens or NFTs to our address, where they will be locked forever. Our smart contract
            ensures these tokens are disposed of responsibly, keeping them out of circulation and your sight.
        </p>
    </div>

    <div class="how-it-works">
        <h2>How It Works</h2>
        <p>
            When you send SCAM or unwanted tokens to TKAN's address, our validator locks them permanently in a specific trash can on
            the blockchain. The validator script ensures that these tokens cannot be moved ever again. This is how we protect
            the Cardano environment.
        </p>
        <p>
            In exchange for a small fee (the same amount the SCAMMER sent you, with a minimum of 2 ADA), those trash tokens will be securely locked.
            If you send more ADA than the required minimum, you'll receive our exclusive <strong>FAN Token</strong> as a reward, allowing you to show your pride as a
            "LION of Cardano" who is helping to maintain a clean ecosystem.
        </p>
        <a class="btn" href="#send-tokens">Send Your Tokens Now</a>
    </div>

    <div id="send-tokens">
        <h2>Send Tokens</h2>
        <p>
            To dispose of your SCAM or unwanted tokens, send them to the following address:
        </p>
        <p><strong>Address:</strong> <code>COMING SOON</code></p>
        <p>
            Help us keep the Cardano ecosystem clean and earn your FAN Token!
        </p>
    </div>

    <div class="wallet-info">
        <h2>Connect Your Wallet</h2>
        <button id="connectWallet" class="btn">Connect Wallet</button>
        <p id="walletAddress">Wallet Address: Not Connected</p>
        <div id="walletBalance">Balance: Not Connected</div>
        <div id="tokenDetails">Tokens: Not yet Available</div>
    </div>
</div>

<div class="footer">
    <p>&copy; 2024 TKAN.io - All Rights Reserved</p>
    <div class="social">
        <p>Follow us on <a href="https://x.com/TKan_Komainu" target="_blank">@TKan_Komainu</a></p>
    </div>
</div>

<script>

// Particle.js Configuration
particlesJS("particles-js", {
    "particles": {
        "number": {
            "value": 80,
            "density": { "enable": true, "value_area": 800 }
        },
        "color": { "value": "#ffffff" },
        "shape": { "type": "circle" },
        "opacity": { "value": 0.5 },
        "size": { "value": 3 },
        "line_linked": {
            "enable": true,
            "distance": 150,
            "color": "#ffffff",
            "opacity": 0.4,
            "width": 1
        },
        "move": {
            "enable": true,
            "speed": 2,
            "direction": "none",
            "random": false,
            "straight": false,
            "out_mode": "out",
            "bounce": false
        }
    }
});

// Helper Functions

/**
 * Converts a hex string to a Uint8Array.
 * @param {string} hex - The hex string.
 * @returns {Uint8Array}
 */
 function hexToUint8Array(hexString) {
  //hexString = hexString.replace(/^0x/, '');
  if (hexString.length % 2 !== 0) {
    throw new Error('Invalid hex string');
  }
  const uint8Array = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    //console.log('hexString.substr(i, 2):', hexString.substr(i, 2));
    uint8Array[i / 2] = parseInt(hexString.substr(i, 2), 16);
    //console.log('uint8Array[i / 2]:', uint8Array);
  }
  return uint8Array;
}

function arrayToHex(byteArray) {
    return byteArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
}

/**
 * Converts a Uint8Array to a hex string.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function bytesToHex(bytes) {
    return Array.from(bytes).map(byte => byte.toString(16).padStart(2, '0')).join('');
}

/**
 * Converts a Uint8Array to a UTF-8 string.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function bytesToString(bytes) {
    try {
        const text = new TextDecoder('utf-8').decode(bytes);
        return text; // Return the decoded text
    } catch (error) {
        console.error('Error decoding bytes to string:', error);
        return ''; // Return an empty string if decoding fails
    }
}

/**
 * Converts a Uint8Array to a fresh ArrayBuffer without offsets.
 * @param {Uint8Array} u8a
 * @returns {ArrayBuffer}
 */
function toArrayBuffer(u8a) {
    const ab = new ArrayBuffer(u8a.length);
    const view = new Uint8Array(ab);
    for (let i = 0; i < u8a.length; ++i) {
        view[i] = u8a[i];
    }
    return ab;
}

/**
 * Parses the amount structure from the decoded UTXO.
 * @param {any} amount - The amount field from the decoded UTXO.
 * @param {Object} tokenBalances - The map to accumulate token balances.
 * @returns {BigInt} - The ADA balance in Lovelace.
 */
 function parseAmount(amountData) {
    let amount = {};

    if (typeof amountData === 'number' || typeof amountData === 'bigint') {
        // Lovelace amount
        amount['lovelace'] = BigInt(amountData);
    } else if (typeof amountData === 'object') {
        for (let [policy, assets] of Object.entries(amountData)) {
            // Convert policy ID if it's an array
            let policyId;
            if (Array.isArray(policy)) {
                policyId = arrayToHex(policy);
            } else {
                policyId = policy;
            }

            for (let [assetName, quantity] of Object.entries(assets)) {
                // Convert asset name if it's an array
                let assetNameHex;
                if (Array.isArray(assetName)) {
                    assetNameHex = arrayToHex(assetName);
                } else {
                    assetNameHex = assetName;
                }

                const unit = policyId + assetNameHex;
                amount[unit] = BigInt(quantity);
            }
        }
    }
    return amount;
}

// Function to convert Uint8Array to hex string
function uint8ArrayToHex(uint8Array) {
    return Array.from(uint8Array)
        .map(byte => byte.toString(16).padStart(2, '0'))
        .join('');
}

/**
 * Decodes a single UTXO from its hex representation.
 * @param {string} utxoHex - The hex string of the UTXO.
 * @returns {Object} - An object containing ADA balance and tokens.
 */
 function decodeUtxo(utxoHex) {
    const utxoBytes = hexToUint8Array(utxoHex);
    //console.log('UTXO Bytes:', utxoBytes);
    const utxo = CBOR.decode(utxoBytes.buffer);
    console.log('Decoded UTXO:', utxo);

    const [txInput, output] = utxo;
    const [txHash, txIndex] = txInput;

    // Log the transaction input and output
    console.log('Transaction Input:', txInput);
    console.log('Transaction Hash:', txHash);
    console.log('Transaction Index:', txIndex);
    console.log('UTXO Output:', output);
    const [outputHash, tokenArray] = output;
    console.log('Output Hash:', outputHash);
    console.log('Token Array:', tokenArray);

    // Extract ADA amount
    const adaAmountArray = tokenArray[0]; // Assuming the first element is the ADA amount in Uint8Array
    const adaBalance = adaAmountArray/1_000_000;
    console.log('ADA Balance:', adaBalance);
    //const adaBalance = adaAmountHex !== undefined ? BigInt('0x' + adaAmountHex) : BigInt(0);
    //console.log('ADA Balance (BigInt):', adaBalance);

    // Extract token amounts
    const tokenBalances = {};
    if (typeof tokenArray[1] === 'object' && tokenArray[1] !== null) {
        for (const policyId in tokenArray[1]) {
            if (tokenArray[1].hasOwnProperty(policyId)) {
                const assetMap = tokenArray[1][policyId]; // Get the asset map for this policy ID

                // Now you can process the assetMap
                for (const assetName in assetMap) {
                    if (assetMap.hasOwnProperty(assetName)) {
                        const quantity = assetMap[assetName]; // Get the quantity for this asset
                        const tokenKey = `${policyId}-${assetName}`; // Create a unique key for the token
                         // Ensure quantity is treated as BigInt
                         const quantityBigInt = BigInt(quantity); // Convert to BigInt

                        // Initialize token balance if it doesn't exist
                        if (!tokenBalances[tokenKey]) {
                            tokenBalances[tokenKey] = BigInt(0); // Initialize with BigInt(0)
                        }

                        // Accumulate the quantity
                        tokenBalances[tokenKey] += quantityBigInt;

                        // Log token details
                        console.log(`Token Policy ID: ${policyId}`);
                        console.log(`Token Asset Name: ${assetName}`);
                        console.log(`Token Quantity (BigInt): ${tokenBalances[tokenKey]}`);
                    }
                }
            }
        }
    } else {
        console.log('No tokens found in this UTXO.');
    }

    return {
        txHash,
        txIndex,
        ada: adaBalance,
        tokens: tokenBalances,
    };
}

function processUtxos(utxos) {
    let totalADA = BigInt(0);
    let totalLocked = BigInt(0);
    let totalCollateral = BigInt(0);
    const tokenBalances = {};

    utxos.forEach((utxoHex, index) => {
        console.log(`Processing UTXO ${index}:`, utxoHex);
        const decodedUtxo = decodeUtxo(utxoHex);
        console.log('Decoded UTXO:', decodedUtxo);
        // Update total ADA balance
        totalADA += decodedUtxo.ada; // Assuming all ADA is available for simplicity

        // Update token balances
        for (const [tokenKey, quantity] of Object.entries(decodedUtxo.tokens)) {
            console.log('Token Key:', tokenKey);
            console.log('Quantity:', quantity);
            tokenBalances[tokenKey] = (tokenBalances[tokenKey] || BigInt(0)) + quantity;
            console.log('Updated Token Balance:', tokenBalances[tokenKey]);
        }
    });

    // Display results
    displayBalances(totalADA, totalLocked, totalCollateral, tokenBalances);
}

function displayBalances(available, locked, collateral, tokenBalances) {
    // Update the UI or console with the balances
    console.log(`Total ADA Available: ${available}`);
    console.log(`Total ADA Locked: ${locked}`);
    console.log(`Total ADA Collateral: ${collateral}`);

    // Update the DOM
    document.getElementById('totalAvailable').innerText = `Total ADA Available: ${(Number(available) / 1_000_000).toFixed(6)} ADA`;
    document.getElementById('totalLocked').innerText = `Total ADA Locked: ${(Number(locked) / 1_000_000).toFixed(6)} ADA`;
    document.getElementById('totalCollateral').innerText = `Total ADA Collateral: ${(Number(collateral) / 1_000_000).toFixed(6)} ADA`;
    
    const tokenListElement = document.getElementById('tokenList');
    tokenListElement.innerHTML = ''; // Clear existing list
    for (const [tokenKey, quantity] of Object.entries(tokenBalances)) {
        const [policyId, assetName] = tokenKey.split('-');
        const listItem = document.createElement('li');
        listItem.innerText = `Token: ${assetName} (Policy: ${policyId}) - Quantity: ${quantity}`;
        tokenListElement.appendChild(listItem);
    }
}

// Function to convert hex to ASCII
function hexToAscii(hex) {
    let str = '';
    for (let i = 0; i < hex.length; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return str;
}

/**
 * Connects to the Eternl wallet and fetches UTXOs.
 */
async function connectWallet() {
    try {
        if (!window.cardano || !window.cardano.eternl) {
            alert('Eternl wallet is not available. Please install Eternl wallet.');
            return;
        }

        const wallet = await window.cardano.eternl.enable();
        console.log("Connected Wallet:", wallet);

        // Get the change address
        const addresses = await wallet.getUsedAddresses();
        if (addresses.length === 0) {
            alert('No addresses found in the wallet.');
            return;
        }
        const address = addresses[0];
        const truncatedAddress = `${address.slice(0, 20)}...${address.slice(-8)}`;
        document.getElementById('walletAddress').innerHTML = `Wallet Address: <code>${truncatedAddress}</code>`;

        // Fetch UTXOs
        const utxos = await wallet.getUtxos();
        console.log("Fetched UTXOs:", utxos);

        if (utxos.length === 0) {
            alert('No UTXOs found in the wallet.');
            document.getElementById('walletBalance').innerHTML = 'Balance: 0 ADA';
            document.getElementById('tokenDetails').innerHTML = 'Tokens: None';
            return;
        }

        // Process UTXOs
        processUtxos(utxos);

    } catch (error) {
        console.error("Error connecting wallet:", error);
        alert('Failed to connect to the wallet. Please check the console for details.');
    }
}

// Event Listener for Connect Wallet Button
document.addEventListener('DOMContentLoaded', () => {
    const connectWalletButton = document.getElementById('connectWallet');
    connectWalletButton.addEventListener('click', connectWallet);
});

</script>

</body>
</html>
