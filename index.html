<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="TKAN - A Cardano Trash Kan to clean up SCAM and unwanted tokens and protect the Cardano ecosystem.">
    <title>TKAN - The Cardano Trash Kan</title>
    <style>
        /* General Reset */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-x: hidden;
        }

        /* Top Section with Particles Background */
        header {
            position: relative;
            height: 300px;
            background: linear-gradient(145deg, #1e1e2f, #2c2c4a);
            color: white;
            text-align: center;
            overflow: hidden;
        }

        #particles-js {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        header img {
            z-index: 1;
            position: relative;
            border-radius: 50%;
            max-width: 150px;
        }

        header h1, header p {
            z-index: 1;
            position: relative;
            margin: 10px;
        }

        /* Content Section */
        .container {
            padding: 20px;
        }

        .send-tokens-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #007bff;
            color: #fff;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
        }

        .send-tokens-btn:hover {
            background: #0056b3;
        }

        h2, h3 {
            color: #1f1f1f;
        }

        .btn {
            display: inline-block;
            background: #007bff;
            color: #fff;
            padding: 10px 20px;
            margin: 20px 0;
            text-decoration: none;
            border-radius: 5px;
            cursor: pointer;
            border: none;
            font-size: 16px;
        }

        .btn:hover {
            background: #0056b3;
        }

        .wallet-info {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .wallet-info p {
            margin: 10px 0;
        }

        .wallet-info code {
            background-color: #f4f4f4;
            padding: 5px;
            border-radius: 3px;
            display: inline-block;
        }

        .footer {
            background: #1f1f1f;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            margin-top: 20px;
        }

        .social {
            margin-top: 10px;
        }

        .social a {
            color: #1da1f2;
            text-decoration: none;
        }

        .social a:hover {
            text-decoration: underline;
        }

        .token-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
        }

        .token-table th,
        .token-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .token-table th {
            background-color: #f5f5f5;
        }

        .token-table td.text-right {
            text-align: right;
        }

        .token-table tr:hover {
            background-color: #f9f9f9;
        }

        .token-table small {
            color: #666;
            font-family: monospace;
        }

        .wallet-balance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .balance-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .token-table-container {
            width: 100%;
            overflow-x: auto;
            margin-top: 1rem;
        }

        .token-table {
            width: 100%;
            min-width: 600px; /* Ensures table doesn't get too squeezed */
            border-collapse: collapse;
        }

        .token-table th,
        .token-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            white-space: nowrap; /* Prevents text wrapping */
        }

        .token-table td:nth-child(2) {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .token-table th {
            background-color: #f5f5f5;
            position: sticky;
            top: 0;
        }

        .token-table td.text-right {
            text-align: right;
        }

        .token-table tr:hover {
            background-color: #f9f9f9;
        }

        .token-table small {
            color: #666;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .wallet-balance-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 480px) {
            .wallet-balance-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cbor-js"></script>
    <script src="https://unpkg.com/@emurgo/cardano-serialization-lib-asmjs@11.5.0/cardano_serialization_lib.js"></script>
</head>
<body>

<header>
    <div id="particles-js"></div>
    <img src="assets/TKAN-logo2.png" alt="TKAN Logo">
    <h1>TKAN - The Cardano Trash Kan</h1>
    <p>Guardians of Purity in the Cardano Ecosystem</p>
</header>

<div class="container">
    <a href="#send-tokens" class="send-tokens-btn">Send Tokens</a>

    <div class="story">
        <h2>Our Mission</h2>
        <p>
            The Cardano ecosystem is filled with clutter from harmful SCAM or unwanted tokens, and trash NFTs. These pollutants
            poison your wallet and the environment. TKAN aims to solve this by creating a "Trash Kan" on the Cardano blockchain.
        </p>
        <p>
            With TKAN, you can send any SCAM or unwanted tokens or NFTs to our address, where they will be locked forever. Our smart contract
            ensures these tokens are disposed of responsibly, keeping them out of circulation and your sight.
        </p>
    </div>

    <div class="how-it-works">
        <h2>How It Works</h2>
        <p>
            When you send SCAM or unwanted tokens to TKAN's address, our validator locks them permanently in a specific trash can on
            the blockchain. The validator script ensures that these tokens cannot be moved ever again. This is how we protect
            the Cardano environment.
        </p>
        <p>
            In exchange for a small fee (the same amount the SCAMMER sent you, with a minimum of 2 ADA), those trash tokens will be securely locked.
            If you send more ADA than the required minimum, you'll receive our exclusive <strong>FAN Token</strong> as a reward, allowing you to show your pride as a
            "LION of Cardano" who is helping to maintain a clean ecosystem.
        </p>
        <a class="btn" href="#send-tokens">Send Your Tokens Now</a>
    </div>

    <div id="send-tokens">
        <h2>Send Tokens</h2>
        <p>
            To dispose of your SCAM or unwanted tokens, send them to the following address:
        </p>
        <p><strong>Address:</strong> <code>COMING SOON</code></p>
        <p>
            Help us keep the Cardano ecosystem clean and earn your FAN Token!
        </p>
    </div>

    <div class="wallet-info">
        <h2>Connect Your Wallet</h2>
        <button id="connectWallet" class="btn">Connect Wallet</button>
        <p id="walletAddress">Wallet Address: Not Connected</p>
        <p id="walletBalance">Balance: Not Connected</p>
        <p id="tokenDetails">Tokens: Not yet Available</p>
    </div>
</div>

<div class="footer">
    <p>&copy; 2024 TKAN.io - All Rights Reserved</p>
    <div class="social">
        <p>Follow us on <a href="https://x.com/TKan_Komainu" target="_blank">@TKan_Komainu</a></p>
    </div>
</div>

<script>

    /* Particle.js Configuration */
    particlesJS("particles-js", {
        "particles": {
            "number": {
                "value": 80,
                "density": { "enable": true, "value_area": 800 }
            },
            "color": { "value": "#ffffff" },
            "shape": { "type": "circle" },
            "opacity": { "value": 0.5 },
            "size": { "value": 3 },
            "line_linked": {
                "enable": true,
                "distance": 150,
                "color": "#ffffff",
                "opacity": 0.4,
                "width": 1
            },
            "move": {
                "enable": true,
                "speed": 2,
                "direction": "none",
                "random": false,
                "straight": false,
                "out_mode": "out",
                "bounce": false
            }
        }
    });
     // Function to decode a hex string to a Uint8Array
    function hexToUint8Array(hex) {
        if (!/^[0-9a-fA-F]*$/.test(hex) || hex.length % 2 !== 0) {
            console.error('Invalid hex string:', hex);
            return new Uint8Array(); // Return an empty array if invalid
        }
        const byteArray = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
            byteArray[i / 2] = parseInt(hex.substr(i, 2), 16);
        }
        return byteArray;
    }

    // Function to convert Uint8Array to hex string
    function bytesToHex(bytes) {
        return Array.from(bytes).map(byte => byte.toString(16).padStart(2, '0')).join('');
    }

    // Function to convert Uint8Array to UTF-8 string
    function bytesToString(bytes) {
        try {
            const text = new TextDecoder('utf-8').decode(bytes);
            return text; // Return the decoded text
        } catch (error) {
            console.error('Error decoding bytes to string:', error);
            return ''; // Return an empty string if decoding fails
        }
    }

    function tryDecodeMultipartName(hex) {
        try {
            // Skip the map marker
            let pos = 2;
            const parts = [];
            
            while (pos < hex.length) {
                // Look for string markers
                if (hex.substr(pos, 2) === '58') {
                    const len = parseInt(hex.substr(pos + 2, 2), 16);
                    const strHex = hex.substr(pos + 4, len * 2);
                    const text = new TextDecoder().decode(hexToUint8Array(strHex));
                    if (/^[\x20-\x7E]*$/.test(text)) {
                        parts.push(text);
                    }
                    pos += 4 + (len * 2);
                } else {
                    pos += 2;
                }
            }
            
            return parts.length > 0 ? parts.join(' ') : null;
        } catch {
            return null;
        }
    }

    // Helper function to convert byte array to hex string
    function toHex(byteArray) {
        if (Array.isArray(byteArray)) {
            return Array.from(byteArray, byte => byte.toString(16).padStart(2, '0')).join('');
        }
        return byteArray;
    }

    // Helper function to try to decode asset name from hex
    function tryDecodeAssetName(hexString) {
        try {
            // Remove any non-hex characters
            const cleanHex = hexString.replace(/[^0-9a-fA-F]/g, '');
            // Convert hex to bytes
            const bytes = new Uint8Array(cleanHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            // Try to decode as UTF-8
            return new TextDecoder().decode(bytes);
        } catch (error) {
            return hexString; // Return original if decode fails
        }
    }

    function hasTokens(value) {
        return typeof value === 'object' && value !== null && Object.keys(value).length > 1;
    }

    function extractTokens(hexString) {
        const tokens = [];
        // Look for token sections starting with '581c'
        let pos = hexString.indexOf('581c');
        
        while (pos !== -1) {
            try {
                // Extract policy ID (56 chars after 581c)
                const policyId = hexString.substring(pos + 4, pos + 60);
                
                // Find token name (starts after policy ID)
                let nameStart = pos + 60;
                // Skip to actual token data
                while (nameStart < hexString.length && 
                       (hexString.substring(nameStart, nameStart + 2) === '01' || 
                        hexString.substring(nameStart, nameStart + 2) === 'a1')) {
                    nameStart += 2;
                }
                
                // Extract token name until next marker or end
                let nameEnd = hexString.indexOf('581c', nameStart);
                if (nameEnd === -1) nameEnd = hexString.length;
                
                const tokenName = hexString.substring(nameStart, nameEnd);
                
                tokens.push({
                    policyId: policyId,
                    name: tokenName
                });
            } catch (error) {
                console.error('Error extracting token:', error);
            }
            
            // Find next token section
            pos = hexString.indexOf('581c', pos + 4);
        }
        
        return tokens;
    }

    function processUtxos(utxos) {
        let totalAdaBalance = 0;
        let availableAdaBalance = 0;
        let lockedAdaBalance = 0;
        let collateralBalance = 0;
        let tokenFragBalance = 0;
        let boundToTokens = 0;
        let tokenBalances = new Map();

        utxos.forEach((utxoHex, index) => {
            try {
                const result = decodeUtxo(utxoHex);
                
                // ADA balance processing
                if (result.ada) {
                    totalAdaBalance += result.ada;
                    if (result.tokens.length === 0) {
                        if (Math.abs(result.ada - 5) < 0.1) {
                            collateralBalance += result.ada;
                        } else {
                            availableAdaBalance += result.ada;
                        }
                    } else {
                        boundToTokens += result.ada;
                    }
                }
                
                // Token processing
                result.tokens.forEach(token => {
                    const policyId = token.policyId;
                    const decodedName = bytesToString(hexToUint8Array(token.name));
                    const key = `${policyId}:${token.name}:${decodedName}`;
                    
                    const tokenAmount = extractTokenAmount(utxoHex, policyId, token.name);
                    const currentAmount = tokenBalances.get(key) || 0;
                    tokenBalances.set(key, currentAmount + tokenAmount);
                });
            } catch (error) {
                console.error(`Error processing UTXO ${index}:`, error);
            }
        });

        // Update displays with corrected balances
        updateWalletDisplay(
            totalAdaBalance,
            availableAdaBalance,
            lockedAdaBalance,
            collateralBalance,
            tokenFragBalance,
            boundToTokens
        );

        updateTokenDisplay(tokenBalances);
    }

    function updateTokenDisplay(tokenBalances) {
        const tokenDetailsDisplay = document.getElementById('tokenDetails');
        let tokenHtml = '<h3>Tokens:</h3><div class="token-table-container">';
        
        if (tokenBalances.size > 0) {
            tokenHtml += `
            <table class="token-table">
                <thead>
                    <tr>
                        <th>Policy ID</th>
                        <th>Token Name</th>
                        <th>Amount</th>
                    </tr>
                </thead>
                <tbody>`;
            
            tokenBalances.forEach((amount, key) => {
                const [policyId, hexName, decodedName] = key.split(':');
                tokenHtml += `
                    <tr>
                        <td>${policyId}</td>
                        <td>${decodedName}</td>
                        <td>${amount}</td>
                    </tr>`;
            });
            
            tokenHtml += '</tbody></table>';
        } else {
            tokenHtml += '<p>No tokens found.</p>';
        }
        
        tokenHtml += '</div>';
        tokenDetailsDisplay.innerHTML = tokenHtml;
    }

    function updateWalletDisplay(totalAda, availableAda, lockedAda, collateralAda, tokenFragAda, boundToTokens) {
        const walletBalanceDisplay = document.getElementById('walletBalance');
        walletBalanceDisplay.innerHTML = `
            <div class="wallet-balance-grid">
                <div class="balance-item">
                    <strong>Total Balance:</strong><br/>
                    ${totalAda.toFixed(6)} ₳
                </div>
                <div class="balance-item">
                    <strong>Available:</strong><br/>
                    ${(availableAda - collateralAda).toFixed(6)} ₳
                </div>
                <div class="balance-item">
                    <strong>Locked:</strong><br/>
                    ${lockedAda.toFixed(6)} ₳
                </div>
                <div class="balance-item">
                    <strong>Collateral:</strong><br/>
                    ${collateralAda.toFixed(6)} ₳
                </div>
                <div class="balance-item">
                    <strong>Bound to tokens:</strong><br/>
                    ${boundToTokens.toFixed(6)} ₳
                </div>
                <div class="balance-item">
                    <strong>Token Fragmentation:</strong><br/>
                    ${tokenFragAda.toFixed(6)} ₳
                </div>
            </div>`;
    }

    function decodeUtxo(utxoHex) {
        try {
            // ADA amount extraction
            const lovelaceMatch = utxoHex.match(/821a([0-9a-f]{8})/);
            let lovelaceAmount = 0;
            
            if (lovelaceMatch) {
                lovelaceAmount = parseInt(lovelaceMatch[1], 16) / 1_000_000;
            }
            
            // Token extraction
            const tokens = [];
            let pos = 0;
            
            while ((pos = utxoHex.indexOf('581c', pos)) !== -1) {
                try {
                    const policyId = utxoHex.substring(pos + 4, pos + 60);
                    let nameStart = pos + 60;
                    
                    // Skip CBOR markers
                    while (nameStart < utxoHex.length && 
                           (utxoHex.substring(nameStart, nameStart + 2) === '01' || 
                            utxoHex.substring(nameStart, nameStart + 2) === 'a1')) {
                        nameStart += 2;
                    }
                    
                    let nameEnd = utxoHex.indexOf('581c', nameStart);
                    if (nameEnd === -1) nameEnd = utxoHex.length;
                    
                    // Directly extract the token name without hex conversion
                    const tokenName = utxoHex.substring(nameStart, nameEnd);
                    
                    tokens.push({
                        policyId: policyId,
                        name: tokenName // Use the extracted name directly
                    });
                } catch (error) {
                    console.error('Error extracting token:', error);
                }
                pos += 4;
            }

            return {
                ada: lovelaceAmount,
                tokens
            };
        } catch (error) {
            console.error('Error decoding UTXO:', error);
            return { ada: 0, tokens: [] };
        }
    }

    function hexToAscii(hex) {
        try {
            let ascii = '';
            for (let i = 0; i < hex.length; i += 2) {
                const charCode = parseInt(hex.substr(i, 2), 16);
                // Only include printable ASCII characters
                if (charCode >= 32 && charCode <= 126) {
                    ascii += String.fromCharCode(charCode);
                }
            }
            return ascii;
        } catch (error) {
            console.error('Error converting hex to ASCII:', error);
            return '';
        }
    }

    async function getWalletUtxos(wallet) {
        try {
            // Get all UTXOs from the wallet
            const utxos = await wallet.getUtxos();
            console.log("Total UTXOs fetched:", utxos.length);
            return utxos;
        } catch (error) {
            console.error("Error fetching UTXOs:", error);
            return [];
        }
    }

    // Add this new function for amount extraction
    function extractTokenAmount(utxoHex, policyId, assetName) {
        try {
            const pattern = `${policyId}${assetName}`;
            const pos = utxoHex.indexOf(pattern);
            
            if (pos !== -1) {
                let amountPos = pos + pattern.length;
                
                // Skip any CBOR map markers
                while (amountPos < utxoHex.length && 
                       (utxoHex.substr(amountPos, 2) === 'a1' || 
                        utxoHex.substr(amountPos, 2) === 'a2')) {
                    amountPos += 2;
                }
                
                const marker = utxoHex.substr(amountPos, 2);
                
                // CBOR integer encoding patterns
                if (marker === '1a') {  // 4-byte integer
                    return parseInt(utxoHex.substr(amountPos + 2, 8), 16);
                } else if (marker === '19') {  // 2-byte integer
                    return parseInt(utxoHex.substr(amountPos + 2, 4), 16);
                } else if (marker === '18') {  // 1-byte integer
                    return parseInt(utxoHex.substr(amountPos + 2, 2), 16);
                } else if (marker === '01') {  // NFT (amount = 1)
                    return 1;
                } else if (marker === '58') {  // String marker
                    const strLen = parseInt(utxoHex.substr(amountPos + 2, 2), 16);
                    const nextPos = amountPos + 4 + (strLen * 2);
                    const nextMarker = utxoHex.substr(nextPos, 2);
                    if (nextMarker === '1a') {
                        return parseInt(utxoHex.substr(nextPos + 2, 8), 16);
                    } else if (nextMarker === '19') {
                        return parseInt(utxoHex.substr(nextPos + 2, 4), 16);
                    }
                }
                
                console.log('Token marker:', marker, 'for token:', assetName);
            }
            return 1;  // Default to 1 if pattern not found
        } catch (error) {
            console.error('Error extracting token amount:', error);
            return 1;
        }
    }

    /* Eternl Wallet Connection Logic */
    document.addEventListener('DOMContentLoaded', () => {
        const connectWalletButton = document.getElementById('connectWallet');
        const walletAddressDisplay = document.getElementById('walletAddress');
        const walletBalanceDisplay = document.getElementById('walletBalance');
        const tokenDetailsDisplay = document.getElementById('tokenDetails');

        connectWalletButton.addEventListener('click', async () => {
            try {
                const wallet = await window.cardano.eternl.enable();
                console.log("Wallet ", wallet);
                
                // Get UTXOs
                const utxos = await getWalletUtxos(wallet);
                console.log("UTXOs:", utxos);
                
                // Process UTXOs
                processUtxos(utxos);
                
                // Update address display
                const addresses = await wallet.getUsedAddresses();
                const addr = addresses[0];
                walletAddressDisplay.textContent = 
                    `Wallet Address: ${addr.substring(0, 20)}...${addr.substring(addr.length - 8)}`;
                
            } catch (error) {
                console.error("Error connecting wallet:", error);
            }
        });
    });
</script>

</body>
